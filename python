Python Cheat Sheet 

+ addition "returns integer"
- subtration "returns interger"
* multiplcation "returns interger"
/ division "returns non-integer"
// division "guaranteed return of an integer 4//3 = 1"
% modulo "returns remainder"
** exponential/power of "returns the power of something - 2**3 = 8"

# Comment with the hashtag symbol



# STRINGS 
----------

Python accepts double quotation and single quotation marks 

print("G'day Mate")
print('G'day Mate') #invalid syntax '

Strings can be treated 'as' variables in python for example

you can concatenate two words together 

print("Hello" + " World")
"Hello World"

print("Hi"+"Hi"+"Hi")
print("Hi" * 3)
"HiHiHi"
"HiHiHi"


# VARIABLES
------------

message = "hello world"
print(message)
"hello world"

# just like the HiHiHi above we can do that using variables

msg = "Hi"
num = 3
print (msg * num)
"HiHiHi"

# Updating variables just by reassigning them

msg = "bye"
msg = msg * 2
print(msg)
"byebye"

# Rules
1. Variables names must start "with" alphabetic letter or an underscore (_)
2. Things you cannot use in a variable name:
	- Whitespaces(space,tab,new line)
	- Hyphens (-)
	- Quotations marks(single/double)
	- Symbol characters (e.g, ?,!,())

# Reserved Words
and, as, assert, break, class, continue, def, del, elif, else, except,  
Flase, finally, for, from, global, if, import, in, is , lambda, None,
nonlocal, not, or, pass, raise, return, True, try, while, with, yield.

# if you want your statement to continue over multiple lines you just write a backslash (\)
my_really_really_realy_clear_name = 7 * 5 * 4 * 2 * 3 + \
									4 + 3 * 42 - 3 
print(my_really_really_realy_clear_name)

# Input - built-in function that can be used to get keyboard input from the user as a string 

name = input("What is your name? ")
age = input("What is your age? ")
print("I know that", name, "is", age, "years old!") #python automatically adds a white space before and after name and age
"I know that Kevin is 20 years old!" 

# the , in the print function combines the arguments together into a single output, separating each adjacent pair with a space



# DATA TYPES
-------------

int 	- # For whole numbers -3, -5, 10
float	- # For real numbers -3.0, 0.5, 3.14159
bool	- # True and False (only two these two values)
str     - # For chunks of text e.g: "Hello World"
tuple	- # For combinations of objects (1,2,3) or (1.0,"hello","frank")
list	- # A more powerful way of storing lists of objects [1,3,4] or [1.0,"hello","frank"]
dict	- # A mapping of a key to a value {"bob" : 34, "stanley" : 54}

# to check if a value is of a certain type:
print(type(23.0)) # <class 'float'>
print(type(1)) # <class 'int'>
print(type(1!=2)) # <class 'bool'>

# to print a value to the power of something 
print(1.55e20) # returns 1.55*10^20

# TYPE CASTING  - converting data into a specific type
print(int(32.7)) #prints 32
print(int("32")) #prints 32 (but as an integer)
print(int("32.7")) #fails as the decimal point is not a digit
print(float("32.7")) #prints 32.7 (but as a float)
print(str("32") + str(32.7)) #prints 3232.7

# input with numbers

num = input('Enter a number to double: ')
print('2 x', num, '=', 2 * num)
# 2 x 20 = 2020

num = int(input('Enter a number to double: ')) # type casting here allows the input to be converted into an integer
print('2 x', num, '=', 2 * num)
# 2 * 20 = 40

# type casting - converts the object from one type to another
# you will fail if you try to convert a float to an integer or a string into a int/float

str -> int
print(int("240")) # 240 (but as an integer)

int -> float
print(float(24)) # 24.0 

float -> str
print(str("24.502")) # 24.502 (but as a string '2','4','.','5','0','2')


# floating point numbers - if a number has ad ecimal play, python will interpret it as a float 
print(3/4) #0.75
print(300000000000.0) # 3e+11
print(1e3) # 1000.0
print(1.23e-2) #0.0123

# expressions
int(*,+,-)int         int
int/int               float # division always makes it a float 
float(*,+,-,/)float   float
float(*,+,-,/)int     float
int(*,+,-,/)float     float


# beware of rounding errors for floating point numbers 
a = 12345678901234567890
b = 0.1
c = a + b - a # 0.0 - due to rounding errors 


# Boolean variables - default values cast to False 
print(bool(1)) # True
print(bool(2.0)) # True
print(bool("False")) # True
print(bool(0)) # False
print(bool(0.0)) # False
print(bool("")) # False
print(bool(False)) # False 



# Binary relational operators 
------------------------------

<	# less than 
<=	# less than or equal
==	# equal
!=	# not equal
>	# greater than
>=	# greater than or equal

print(1 > 2)		# False
print(1 + 1 >= 1)	# True	
print(2 == 4/2)	 	# True

# Strings are compared and sorted by their alphabetical order ** Lowercase letters are greater than Uppercase letters
print('he'<'hi')			# True
print('Help' >= 'Hello')	# False
print('h' > 'H') 			# True
print('Z' < 'a')			# True

# if you want to see why you can use ord('a'), it returns the numerical value of each alphabet

print(ord('a'))	# 97
print(ord('A'))	# 65
print('a'>'A')	# True

# We can check if a string is a substring of another string - whether there's 'texta' in 'textb'

print('Hi' in 'HiHi')	# True
print('Hi' in 'hi') 	# False

# ordering of string matters

print('le' in 'hello')	# False
print('' in 'hello')	# Trie

print(True and True)	# True 
print(True and 1 != 1)	# False (as long as there's a False it will return false)
print(1 > 2 or True)	# True (as long as there's a True it will return true)
print(not True)			# False (negating a true will give you a false, vice versa)

# precedence in logical operators -- in > not > and > or

print(not 1 > 2 and 1 > 0 or "din" in "coding") # True
# python first evaluates 1>2, 1>0 and "din" in "coding"
# not False and True or True
# True and True or True 
# True or True (True and True == True)
# True --

print("Monday" and not "holiday" and not "birthday")
# what do you think this evaluates to?
# Every non-empty string evalutes to True
# so this means - True and not True and not True
# True and False and False
# False 

n = 4 
print((0<n) and (n<6)) # True
print(0<n<6) # True (short version)


# uing if-elif-elif-elif-else statements (elif can be used multiple times but if-else only once)

n = int(input("Enter an integer: "))
if 0 < n < 16:
	print('You entered a postiive integer less than 16') 
print('Try again with another interger!') # if the value is not between 0 and 16, you wil see this



# Conditionals
---------------

# indentation is used so python knows what statement to run when the if statement is True
# If there were more lines of code associated with the if statement, it would simlarly be indented
# This combined set of staments is termed a block and the general form of an inf statement is as follows:

if condition:
	# first condition block

elif condition:
	# alternative condition block

else:
	# alternative condition block

# multiple conditions: 

if cond:
	# block 1 of statements

elif cond2:
	# block 2 of statements

elif cond3:
	# block 3 of statements

else:
	# block n of statements 

# Tip:
# Always (at least consider) include an else clause. This ensures there is always something
# for python to run, and forces you to think about all the cases. If you do not have an else
# clause, but just a sequence of if.. elif... there is a chance non of the elif conditions are
# true, and then nothing happens. This is a very COMMON ERROR! 

# Example:

number = int(input("Enter a number: "))
if (number>5):
	message = "The number is greater than 5"
elif(number<5):
	message = "The number is less than 5"
print(messsage)

# if you included the else clause they would have remembered that the number could be 5 also.
# ** It is also bad practice to define variables inside if blocks, there's a better version below: **

number = int(input("Enter a number:"))
message = "a message"
if (number > 5):
	message = "The number is greater than 5"
elif (number < 5):
	message = "The number is less than 5":
else:
	message = "The number is five!"
print(message)


# special symbols being used as markers ^ and $

name = "^" + input("Subject: ") + "$"
if "omics$" in name:
	print ("Life science Major")
elif "^comp" in name or "^info" in name:
	print("Computer Major")
elif "$y" in name:
	print("Biology Major")
else:
	print("Not science major")

# as you can see, the markers are use to meet the requirements of the conditions



# Sequences
------------
# A sequence is like a numbebred list of objects (like a shopping list)

"44 cats"

# They are sequences of smaller strings, one for each character
# The positions of characters within a string are numbered

"4" "4" " " "c" "a" "t" "s"
 0   1   2   3   4   5   6 

# To access a character at a particular postion we specify its poistion using numbers 
# in a square brackets (e.g [1]). This is called indexing or subscripting the string.
# the number inside the brackets is called the index. Example below: 

s = "The number is 69"
print(s[0]) # T
print(s[1]) # h
print(s[2]) # e

# what happens when you try to index outside of the string say s[17]?
# try it what happens?
# you get an error message
# So how do you find out the length of the string? 

n = len(s)
print(n) # 16 
print(len("Hello")) # 5

# what happens if we index a negative number (e.g.,[-2])

s = "The number is 69"
print(s[-1]) # 9
print(s[-2]) # 6
print(s[-4]) # s

# negative indexing start from the end of the string and starts with -1 not -0 (there's no such thing as -0)































































