Python Cheat Sheet 

+ addition "returns integer"
- subtration "returns interger"
* multiplcation "returns interger"
/ division "returns non-integer"
// division "guaranteed return of an integer 4//3 = 1"
% modulo "returns remainder"
** exponential/power of "returns the power of something - 2**3 = 8"

# Comment with the hashtag symbol



# STRINGS 
----------

Python accepts double quotation and single quotation marks 

print("G'day Mate")
print('G'day Mate') #invalid syntax '

Strings can be treated 'as' variables in python for example

you can concatenate two words together 

print("Hello" + " World")
"Hello World"

print("Hi"+"Hi"+"Hi")
print("Hi" * 3)
"HiHiHi"
"HiHiHi"


# VARIABLES
------------

message = "hello world"
print(message)
"hello world"

# just like the HiHiHi above we can do that using variables

msg = "Hi"
num = 3
print (msg * num)
"HiHiHi"

# Updating variables just by reassigning them

msg = "bye"
msg = msg * 2
print(msg)
"byebye"

# Rules
1. Variables names must start "with" alphabetic letter or an underscore (_)
2. Things you cannot use in a variable name:
	- Whitespaces(space,tab,new line)
	- Hyphens (-)
	- Quotations marks(single/double)
	- Symbol characters (e.g, ?,!,())

# Reserved Words
and, as, assert, break, class, continue, def, del, elif, else, except,  
Flase, finally, for, from, global, if, import, in, is , lambda, None,
nonlocal, not, or, pass, raise, return, True, try, while, with, yield.

# if you want your statement to continue over multiple lines you just write a backslash (\)
my_really_really_realy_clear_name = 7 * 5 * 4 * 2 * 3 + \
									4 + 3 * 42 - 3 
print(my_really_really_realy_clear_name)

# Input - built-in function that can be used to get keyboard input from the user as a string 

name = input("What is your name? ")
age = input("What is your age? ")
print("I know that", name, "is", age, "years old!") #python automatically adds a white space before and after name and age
"I know that Kevin is 20 years old!" 

# the , in the print function combines the arguments together into a single output, separating each adjacent pair with a space



# DATA TYPES
-------------

int 	- # For whole numbers -3, -5, 10
float	- # For real numbers -3.0, 0.5, 3.14159
bool	- # True and False (only two these two values)
str     - # For chunks of text e.g: "Hello World"
tuple	- # For combinations of objects (1,2,3) or (1.0,"hello","frank")
list	- # A more powerful way of storing lists of objects [1,3,4] or [1.0,"hello","frank"]
dict	- # A mapping of a key to a value {"bob" : 34, "stanley" : 54}

# to check if a value is of a certain type:
print(type(23.0)) # <class 'float'>
print(type(1)) # <class 'int'>
print(type(1!=2)) # <class 'bool'>

# to print a value to the power of something 
print(1.55e20) # returns 1.55*10^20

# TYPE CASTING  - converting data into a specific type
print(int(32.7)) #prints 32
print(int("32")) #prints 32 (but as an integer)
print(int("32.7")) #fails as the decimal point is not a digit
print(float("32.7")) #prints 32.7 (but as a float)
print(str("32") + str(32.7)) #prints 3232.7

# input with numbers

num = input('Enter a number to double: ')
print('2 x', num, '=', 2 * num)
# 2 x 20 = 2020

num = int(input('Enter a number to double: ')) # type casting here allows the input to be converted into an integer
print('2 x', num, '=', 2 * num)
# 2 * 20 = 40

# type casting - converts the object from one type to another
# you will fail if you try to convert a float to an integer or a string into a int/float

str -> int
print(int("240")) # 240 (but as an integer)

int -> float
print(float(24)) # 24.0 

float -> str
print(str("24.502")) # 24.502 (but as a string '2','4','.','5','0','2')


# floating point numbers - if a number has ad ecimal play, python will interpret it as a float 
print(3/4) #0.75
print(300000000000.0) # 3e+11
print(1e3) # 1000.0
print(1.23e-2) #0.0123

# expressions
int(*,+,-)int         int
int/int               float # division always makes it a float 
float(*,+,-,/)float   float
float(*,+,-,/)int     float
int(*,+,-,/)float     float


# beware of rounding errors for floating point numbers 
a = 12345678901234567890
b = 0.1
c = a + b - a # 0.0 - due to rounding errors 


# Boolean variables - default values cast to False 
print(bool(1)) # True
print(bool(2.0)) # True
print(bool("False")) # True
print(bool(0)) # False
print(bool(0.0)) # False
print(bool("")) # False
print(bool(False)) # False 



# Binary relational operators 
------------------------------

<	# less than 
<=	# less than or equal
==	# equal
!=	# not equal
>	# greater than
>=	# greater than or equal

print(1 > 2)		# False
print(1 + 1 >= 1)	# True	
print(2 == 4/2)	 	# True

# Strings are compared and sorted by their alphabetical order ** Lowercase letters are greater than Uppercase letters
print('he'<'hi')			# True
print('Help' >= 'Hello')	# False
print('h' > 'H') 			# True
print('Z' < 'a')			# True

# if you want to see why you can use ord('a'), it returns the numerical value of each alphabet

print(ord('a'))	# 97
print(ord('A'))	# 65
print('a'>'A')	# True

# We can check if a string is a substring of another string - whether there's 'texta' in 'textb'

print('Hi' in 'HiHi')	# True
print('Hi' in 'hi') 	# False

# ordering of string matters

print('le' in 'hello')	# False
print('' in 'hello')	# Trie

print(True and True)	# True 
print(True and 1 != 1)	# False (as long as there's a False it will return false)
print(1 > 2 or True)	# True (as long as there's a True it will return true)
print(not True)			# False (negating a true will give you a false, vice versa)

# precedence in logical operators -- in > not > and > or

print(not 1 > 2 and 1 > 0 or "din" in "coding") # True
# python first evaluates 1>2, 1>0 and "din" in "coding"
# not False and True or True
# True and True or True 
# True or True (True and True == True)
# True --

print("Monday" and not "holiday" and not "birthday")
# what do you think this evaluates to?
# Every non-empty string evalutes to True
# so this means - True and not True and not True
# True and False and False
# False 

n = 4 
print((0<n) and (n<6)) # True
print(0<n<6) # True (short version)


# uing if-elif-elif-elif-else statements (elif can be used multiple times but if-else only once)

n = int(input("Enter an integer: "))
if 0 < n < 16:
	print('You entered a postiive integer less than 16') 
print('Try again with another interger!') # if the value is not between 0 and 16, you wil see this



# Conditionals
---------------

# indentation is used so python knows what statement to run when the if statement is True
# If there were more lines of code associated with the if statement, it would simlarly be indented
# This combined set of staments is termed a block and the general form of an inf statement is as follows:

if condition:
	# first condition block

elif condition:
	# alternative condition block

else:
	# alternative condition block

# multiple conditions: 

if cond:
	# block 1 of statements

elif cond2:
	# block 2 of statements

elif cond3:
	# block 3 of statements

else:
	# block n of statements 

# Tip:
# Always (at least consider) include an else clause. This ensures there is always something
# for python to run, and forces you to think about all the cases. If you do not have an else
# clause, but just a sequence of if.. elif... there is a chance non of the elif conditions are
# true, and then nothing happens. This is a very COMMON ERROR! 

# Example:

number = int(input("Enter a number: "))
if (number>5):
	message = "The number is greater than 5"
elif(number<5):
	message = "The number is less than 5"
print(messsage)

# if you included the else clause they would have remembered that the number could be 5 also.
# ** It is also bad practice to define variables inside if blocks, there's a better version below: **

number = int(input("Enter a number:"))
message = "a message"
if (number > 5):
	message = "The number is greater than 5"
elif (number < 5):
	message = "The number is less than 5":
else:
	message = "The number is five!"
print(message)


# special symbols being used as markers ^ and $

name = "^" + input("Subject: ") + "$"
if "omics$" in name:
	print ("Life science Major")
elif "^comp" in name or "^info" in name:
	print("Computer Major")
elif "$y" in name:
	print("Biology Major")
else:
	print("Not science major")

# as you can see, the markers are use to meet the requirements of the conditions



# Sequences
------------
# A sequence is like a numbebred list of objects (like a shopping list)

"44 cats"

# They are sequences of smaller strings, one for each character
# The positions of characters within a string are numbered

"4" "4" " " "c" "a" "t" "s"
 0   1   2   3   4   5   6 

# To access a character at a particular postion we specify its poistion using numbers 
# in a square brackets (e.g [1]). This is called indexing or subscripting the string.
# the number inside the brackets is called the index. Example below: 

s = "The number is 69"
print(s[0]) # T
print(s[1]) # h
print(s[2]) # e

# what happens when you try to index outside of the string say s[17]?
# try it what happens?
# you get an error message
# So how do you find out the length of the string? 

n = len(s)
print(n) # 16 
print(len("Hello")) # 5

# what happens if we index a negative number (e.g.,[-2])

s = "The number is 69"
print(s[-1]) # 9
print(s[-2]) # 6
print(s[-4]) # s

# negative indexing start from the end of the string and starts with -1 not -0 (there's no such thing as -0)

# what if we want a specific part (substring) of the sequence?
# we call this a slice

s = "The number is 69"
print(s[1:8]) # he numb
print(s[0:len(s)]) # The number is 69

# you can also slice negative indices

s = "The number is 69"
print(s[4:-6]) # number
print(s[-6:-1]) # is 6
print(s[-6:len(s)]) # is 69

# python gives 2 shortcuts when it comes to slicing:
s = "The number is 69"
# 1. If the start index is 0 then you can leave it blank
print(s[:5]) # The n

# 2. If the end index is the length of the string then you can leave it blank
print(s[5:]) # umber is 69
print(s[:]) # The number is 69


# you can also tell python how much to step through the list
s = "abcdef"
print(s[::2]) # ace
print(s[0:3:2]) # ac
# if the third digit in the splice is a negative number, it reverses the direction
print(s[2::-1]) # cba 
print(s[2:0:-1]) # cb
print(s[-4:-6:-1]) # cb

# if there is nothing in betwee nthe indices, an empty string is returned
# unlike indexing beyond the len(s) which returns an error an empty string is returned

print(s[0:2:-1]) # ""



# LISTS
--------
# Another form of sequences used for stroing sequences of different objects 
# this is useful when wanting to store a list of words and finding which is the longest 
# or a the cost of items or maybe a list of both

# This is how we define a list 
my_words = ["pig","pineapple","panoply","polyp"]
my_costs = [5.0, 12.0, 20000000.59]
my_jumble = ["jumbly","wumbly","number",5]

# An empty list looks like this
empty = []

# Once you have created a list, you can do everything you have seen for strings as both are sequences 
# strings are sequences of characters, and lists are sequences of whatever objects you like 

my_jumble = ["jumbly","wumbly","number",5]

print(my_jumble) # ["jumbly","wumbly","number",5]
print(my_jumble[1]) # "wumbly"
print(my_jumble[-1]) # 5
print(my_jumble[:1:-1]) # [5, "number"]

# you can find the len of the list too:

print(len(my_jumble)) # 4

print(my_jumble[9]) # returns IndexError: list index out of range 

# we can also concatenate lists just like strings 

my_list = [1,2,3] + [4,5,6]
print(my_list) # [1,2,3,4,5,6]

# remember what happens when we multiply a string? 
# the same can be used on a list 

my_list = [1,2,3] * 5
print(my_list) # [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]

# finally the 'in' operator also works for lists

my_list = [1,2,3]
print(1 in my_list) # True



# TUPLES
---------
# This is essentially the same as a list, but it can't be changed after creation (immutable)
# this will make more sense when we get to a later part in this tutorial 
# tuples work the same as lists but uses () instead of []

single = (3,)
print(len(single)) # 1
# notice how there is a ',' after the 3
# this lets python know that you're assigning a tuple to single instead of an integer 
# if you put single = (3), python will think it's just an integer 
# and you can't find the len(single) of an integer if it were just (3) instead of (3,)

# and we can do all the same things as we have seen over other sequences: 

my_tuple = ('height', 3, 'age', 70)
print(my_tuple) # ('height', 3, 'age', 70)
print(my_tuple[1]) # 3
print(my_tuple[-1]) # 70
print(my_tuple[:1:-1]) # ('age', 70)

# There is more complete list of all operations and properties of sequences in the link below
# docs.python.org/3/library/stdtypes.html



# Functions
------------
# Think of this as a formula to achieve something
# writing functions help you streamline code so it doesn't need to be copy and pasted here and there

# suppose we have the following formula for the number of standard drinks in a drink

volume = 0.375
percentage = 13.5
drinks = volume * percentage * 0.789
print(drinks)

# But what if we want to perfrom this calculation over different values of volumes and percentages 

def std_drinks(volume,percentage):
	return volume * percentage * 0.789

print(std_drinks(0.375,13.5)) # 3.99431250000004
print(std_drinks(0.586,3.8)) # 1.7569452
print(std_drinks(1.5,0)) # 0.0

# Take a look at another exmaple:
# Calculate the number of standard drinks contained in 'volume'
# of alcoholic drink `percentage` % of alcohol

def std_drinks(volume,percentage):
	return volume * percentage * 0.789

# We use the function to do the calculation
print(std_drinks(0.375,13.5))
# The values taken into the function are called arguments and using by using a func you're calling a func

# Why use functions?
# 1. Saves space by reducing repeated code
# 2. If there was an error in the function we would only have to fix it once rather than every other duplicate 

# We've actually already seen some arguments before, can you guess them? 

len([1,2,3]) # function that calculates the lenght of string/list/tuple
print("hello","bob") # print function that took 2 arguments

# if you notice, functions always have () after the function name lower(), len(), type(), 

# The basic components of a function are:
# 1. The function name - follow the same rule as variables, they must start with a letter or an underscore
def my_function_name

# 2. The arguments - variables that will be passed on into the code segment in the function
def my_function_name(arg1,arg2,arg3):

# 3. The actual computation that the funciton does when called
def my_function_name(arg1,arg2,arg3):
	maxnum = arg1
	if arg1 > maxnum:
		maxnum = num1
	elif arg2 > maxnum:
		maxnum = arg2 

# 4. Some mechanism for returning a value and exiting the function 
def my_function_name(arg1,arg2,arg3):
	maxnum = arg1
	if arg1 > maxnum:
		maxnum = num1
	elif arg2 > maxnum:
		maxnum = arg2 
	return maxnum


# Functions do not display any output on the screen unless the output is explicitly printed 

def silly_fucntion():
	return "I'm silly"

w = silly_fucntion # return value is stored but not displayed
print(w) # returns "I'm silly"


# Note that a function has to be defined before you can call it, so always have your function above you call because python reads top-down

def a_function():
	print("Returning a number: ")
	return 1
	print("Returning a number: ")
	return 3 

# the output will be 
# Returning a number: 
# 1 

# When the return statement is executed, the function "stops" and returns the value given. This means that anything below it will be ignored/not executed 

# A function can have as many arguments as needed 
def a_function(arg1,arg2,...,argn):

# The arguments however need to have different names 
def a_fucntion(a,a,a,): # WRONG
def a_function(a,b,c): # RIGHT

# A function can also have no arguments 
def a_fucntion():
	return -1
print(error_code())


# METHODS 
----------
# These are special functions that belong to specific data types. They are written and called a bit differently.
# An example of a method is upper() method, which converts the string to uppercase and returns it.

my_str = "take the pie out"
print(my_str) # "take the pie out"
prtin(my_str.upper()) # "TAKE THE PIE OUT"

# Just as was the case with functions, methods calls always require parentheses, and if there are not extra (arguments)
# the parentheses should be empty. However methods always get object they're called from as an argument. So in this case
# upper() received my_str as an argument automatically

# Try and write a fucntion that utilises a method to count the number of words in a sentence
# solution below if you can't figure it out, ** tip: use .split()

def word_count(input_str):
	words = input_str.split()
	return len(words)


# One str method that is particulrl useful is format
# The power of format is displayed below 

num1 = 5 
num2 = 6.7

print("The quotient of " + str(num1) + " and " + str(num2)+ " is " + str(num1/num2))
print("The quotient of",num1,"and",num2,"is",num1/num2)

# string concatenation involves casting every value to a string, which is tedious,
# we have no way of controlling the number of decimal places a given float is printed to
# and print with multiple arguments inserts a space between each pair of arguments 

# The power of formal allows us to simplify this

print("The quotion of {} and {} is {:.2f}".format(num1,num2,num1/num2))


# Lets start with a simple example of format:

print("I own {} horses". format(10)) # "I own 10 horses."

# In this example, the format string is "I own {} horses." The format method is used to gnerate a new
# string by substituting a value into a format string. THe empty curly braces {} are used to tell the 
# format method where in the string the value should go.

# For floating point numbers, Python has even finner control. THe format specifier {:6.2f} tells format
# to use at least 6 characters in total and use exactly two digits after the deicmal points

pi = 3.1415926
print("{:<6.2f}".format(pi)) # pad on the right
3.14  # Total of 6 spaces used
print("{:6.2f}".format(pi)) # pad on the left
  3.14# Total of 6 spaces used

# format also has the ability to embed different types (not just numbers) in strings like so:

print("strings: {:s}".format("9743")) # strings: 9743
print("binary number: {:b}".format(9743)) # binary number: 10011000001111
print("integer base 10: {:d}".format(9743)) # integer base 10: 9743 
print("Call me on my {:c}".format(9743)) # (picture of a telephone)
# {:c} converts the integer into a special character 
# It's called Unicode characters 

# If there is nothing before the colon, Python will substitue in the arguments to format in sequence
# i.e. the first argument to format will be substituted for the first occurerence of curly braces, the
# second for the second, etc. You can also, however, index the arguments to format in the same way that
# you index the elemtns of a list, e.g.:

print("{0} {0} It's off to work we go".format("Hi Ho!"))
# Hi Ho! Hi Ho! It's off to work we go

print("""{t1} and {t2} 
	Agreed to have a battle;
For {t1} and {t2}
	Had spoiled his nice new rattle.""".format(t1="Tweedledum",t2="Tweedledee"))

# Tweedledum and Tweedledee
# 	Agreed to have a battle;
# For Tweedledum and Tweedledee
#	Had poiled his nice new rattle. 

# More resources if you want to learn more at:
# pyformat.info 
# docs.python.org/3/library/string.html#format-string-syntax






















































