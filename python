Python Cheat Sheet 

+ addition "returns integer"
- subtration "returns interger"
* multiplcation "returns interger"
/ division "returns non-integer"
// division "guaranteed return of an integer 4//3 = 1"
% modulo "returns remainder"
** exponential/power of "returns the power of something - 2**3 = 8"

# Comment with the hashtag symbol



# STRINGS 
----------

Python accepts double quotation and single quotation marks 

print("G'day Mate")
print('G'day Mate') #invalid syntax '

Strings can be treated 'as' variables in python for example

you can concatenate two words together 

print("Hello" + " World")
"Hello World"

print("Hi"+"Hi"+"Hi")
print("Hi" * 3)
"HiHiHi"
"HiHiHi"


# VARIABLES
------------

message = "hello world"
print(message)
"hello world"

# just like the HiHiHi above we can do that using variables

msg = "Hi"
num = 3
print (msg * num)
"HiHiHi"

# Updating variables just by reassigning them

msg = "bye"
msg = msg * 2
print(msg)
"byebye"

# Rules
1. Variables names must start "with" alphabetic letter or an underscore (_)
2. Things you cannot use in a variable name:
	- Whitespaces(space,tab,new line)
	- Hyphens (-)
	- Quotations marks(single/double)
	- Symbol characters (e.g, ?,!,())

# Reserved Words
and, as, assert, break, class, continue, def, del, elif, else, except,  
Flase, finally, for, from, global, if, import, in, is , lambda, None,
nonlocal, not, or, pass, raise, return, True, try, while, with, yield.

# if you want your statement to continue over multiple lines you just write a backslash (\)
my_really_really_realy_clear_name = 7 * 5 * 4 * 2 * 3 + \
									4 + 3 * 42 - 3 
print(my_really_really_realy_clear_name)

# Input - built-in function that can be used to get keyboard input from the user as a string 

name = input("What is your name? ")
age = input("What is your age? ")
print("I know that", name, "is", age, "years old!") #python automatically adds a white space before and after name and age
"I know that Kevin is 20 years old!" 

# the , in the print function combines the arguments together into a single output, separating each adjacent pair with a space



# DATA TYPES
-------------

int 	- # For whole numbers -3, -5, 10
float	- # For real numbers -3.0, 0.5, 3.14159
bool	- # True and False (only two these two values)
str     - # For chunks of text e.g: "Hello World"
tuple	- # For combinations of objects (1,2,3) or (1.0,"hello","frank")
list	- # A more powerful way of storing lists of objects [1,3,4] or [1.0,"hello","frank"]
dict	- # A mapping of a key to a value {"bob" : 34, "stanley" : 54}

# to check if a value is of a certain type:
print(type(23.0)) # <class 'float'>
print(type(1)) # <class 'int'>
print(type(1!=2)) # <class 'bool'>

# to print a value to the power of something 
print(1.55e20) # returns 1.55*10^20

# TYPE CASTING  - converting data into a specific type
print(int(32.7)) #prints 32
print(int("32")) #prints 32 (but as an integer)
print(int("32.7")) #fails as the decimal point is not a digit
print(float("32.7")) #prints 32.7 (but as a float)
print(str("32") + str(32.7)) #prints 3232.7

# input with numbers

num = input('Enter a number to double: ')
print('2 x', num, '=', 2 * num)
# 2 x 20 = 2020

num = int(input('Enter a number to double: ')) # type casting here allows the input to be converted into an integer
print('2 x', num, '=', 2 * num)
# 2 * 20 = 40

# type casting - converts the object from one type to another
# you will fail if you try to convert a float to an integer or a string into a int/float

str -> int
print(int("240")) # 240 (but as an integer)

int -> float
print(float(24)) # 24.0 

float -> str
print(str("24.502")) # 24.502 (but as a string '2','4','.','5','0','2')


# floating point numbers - if a number has ad ecimal play, python will interpret it as a float 
print(3/4) #0.75
print(300000000000.0) # 3e+11
print(1e3) # 1000.0
print(1.23e-2) #0.0123

# expressions
int(*,+,-)int         int
int/int               float # division always makes it a float 
float(*,+,-,/)float   float
float(*,+,-,/)int     float
int(*,+,-,/)float     float


# beware of rounding errors for floating point numbers 
a = 12345678901234567890
b = 0.1
c = a + b - a # 0.0 - due to rounding errors 


# Boolean variables - default values cast to False 
print(bool(1)) # True
print(bool(2.0)) # True
print(bool("False")) # True
print(bool(0)) # False
print(bool(0.0)) # False
print(bool("")) # False
print(bool(False)) # False 



# Binary relational operators 
------------------------------

<	# less than 
<=	# less than or equal
==	# equal
!=	# not equal
>	# greater than
>=	# greater than or equal

print(1 > 2)		# False
print(1 + 1 >= 1)	# True	
print(2 == 4/2)	 	# True

# Strings are compared and sorted by their alphabetical order ** Lowercase letters are greater than Uppercase letters
print('he'<'hi')			# True
print('Help' >= 'Hello')	# False
print('h' > 'H') 			# True
print('Z' < 'a')			# True

# if you want to see why you can use ord('a'), it returns the numerical value of each alphabet

print(ord('a'))	# 97
print(ord('A'))	# 65
print('a'>'A')	# True

# We can check if a string is a substring of another string - whether there's 'texta' in 'textb'

print('Hi' in 'HiHi')	# True
print('Hi' in 'hi') 	# False

# ordering of string matters

print('le' in 'hello')	# False
print('' in 'hello')	# Trie

print(True and True)	# True 
print(True and 1 != 1)	# False (as long as there's a False it will return false)
print(1 > 2 or True)	# True (as long as there's a True it will return true)
print(not True)			# False (negating a true will give you a false, vice versa)

# precedence in logical operators -- in > not > and > or

print(not 1 > 2 and 1 > 0 or "din" in "coding") # True
# python first evaluates 1>2, 1>0 and "din" in "coding"
# not False and True or True
# True and True or True 
# True or True (True and True == True)
# True --

print("Monday" and not "holiday" and not "birthday")
# what do you think this evaluates to?
# Every non-empty string evalutes to True
# so this means - True and not True and not True
# True and False and False
# False 

n = 4 
print((0<n) and (n<6)) # True
print(0<n<6) # True (short version)


# uing if-elif-elif-elif-else statements (elif can be used multiple times but if-else only once)

n = int(input("Enter an integer: "))
if 0 < n < 16:
	print('You entered a postiive integer less than 16') 
print('Try again with another interger!') # if the value is not between 0 and 16, you wil see this



# Conditionals
---------------

# indentation is used so python knows what statement to run when the if statement is True
# If there were more lines of code associated with the if statement, it would simlarly be indented
# This combined set of staments is termed a block and the general form of an inf statement is as follows:

if condition:
	# first condition block

elif condition:
	# alternative condition block

else:
	# alternative condition block

# multiple conditions: 

if cond:
	# block 1 of statements

elif cond2:
	# block 2 of statements

elif cond3:
	# block 3 of statements

else:
	# block n of statements 

# Tip:
# Always (at least consider) include an else clause. This ensures there is always something
# for python to run, and forces you to think about all the cases. If you do not have an else
# clause, but just a sequence of if.. elif... there is a chance non of the elif conditions are
# true, and then nothing happens. This is a very COMMON ERROR! 

# Example:

number = int(input("Enter a number: "))
if (number>5):
	message = "The number is greater than 5"
elif(number<5):
	message = "The number is less than 5"
print(messsage)

# if you included the else clause they would have remembered that the number could be 5 also.
# ** It is also bad practice to define variables inside if blocks, there's a better version below: **

number = int(input("Enter a number:"))
message = "a message"
if (number > 5):
	message = "The number is greater than 5"
elif (number < 5):
	message = "The number is less than 5":
else:
	message = "The number is five!"
print(message)


# special symbols being used as markers ^ and $

name = "^" + input("Subject: ") + "$"
if "omics$" in name:
	print ("Life science Major")
elif "^comp" in name or "^info" in name:
	print("Computer Major")
elif "$y" in name:
	print("Biology Major")
else:
	print("Not science major")

# as you can see, the markers are use to meet the requirements of the conditions



# Sequences
------------
# A sequence is like a numbebred list of objects (like a shopping list)

"44 cats"

# They are sequences of smaller strings, one for each character
# The positions of characters within a string are numbered

"4" "4" " " "c" "a" "t" "s"
 0   1   2   3   4   5   6 

# To access a character at a particular postion we specify its poistion using numbers 
# in a square brackets (e.g [1]). This is called indexing or subscripting the string.
# the number inside the brackets is called the index. Example below: 

s = "The number is 69"
print(s[0]) # T
print(s[1]) # h
print(s[2]) # e

# what happens when you try to index outside of the string say s[17]?
# try it what happens?
# you get an error message
# So how do you find out the length of the string? 

n = len(s)
print(n) # 16 
print(len("Hello")) # 5

# what happens if we index a negative number (e.g.,[-2])

s = "The number is 69"
print(s[-1]) # 9
print(s[-2]) # 6
print(s[-4]) # s

# negative indexing start from the end of the string and starts with -1 not -0 (there's no such thing as -0)

# what if we want a specific part (substring) of the sequence?
# we call this a slice

s = "The number is 69"
print(s[1:8]) # he numb
print(s[0:len(s)]) # The number is 69

# you can also slice negative indices

s = "The number is 69"
print(s[4:-6]) # number
print(s[-6:-1]) # is 6
print(s[-6:len(s)]) # is 69

# python gives 2 shortcuts when it comes to slicing:
s = "The number is 69"
# 1. If the start index is 0 then you can leave it blank
print(s[:5]) # The n

# 2. If the end index is the length of the string then you can leave it blank
print(s[5:]) # umber is 69
print(s[:]) # The number is 69


# you can also tell python how much to step through the list
s = "abcdef"
print(s[::2]) # ace
print(s[0:3:2]) # ac
# if the third digit in the splice is a negative number, it reverses the direction
print(s[2::-1]) # cba 
print(s[2:0:-1]) # cb
print(s[-4:-6:-1]) # cb

# if there is nothing in betwee nthe indices, an empty string is returned
# unlike indexing beyond the len(s) which returns an error an empty string is returned

print(s[0:2:-1]) # ""



# LISTS
--------
# Another form of sequences used for stroing sequences of different objects 
# this is useful when wanting to store a list of words and finding which is the longest 
# or a the cost of items or maybe a list of both

# This is how we define a list 
my_words = ["pig","pineapple","panoply","polyp"]
my_costs = [5.0, 12.0, 20000000.59]
my_jumble = ["jumbly","wumbly","number",5]

# An empty list looks like this
empty = []

# Once you have created a list, you can do everything you have seen for strings as both are sequences 
# strings are sequences of characters, and lists are sequences of whatever objects you like 

my_jumble = ["jumbly","wumbly","number",5]

print(my_jumble) # ["jumbly","wumbly","number",5]
print(my_jumble[1]) # "wumbly"
print(my_jumble[-1]) # 5
print(my_jumble[:1:-1]) # [5, "number"]

# you can find the len of the list too:

print(len(my_jumble)) # 4

print(my_jumble[9]) # returns IndexError: list index out of range 

# we can also concatenate lists just like strings 

my_list = [1,2,3] + [4,5,6]
print(my_list) # [1,2,3,4,5,6]

# remember what happens when we multiply a string? 
# the same can be used on a list 

my_list = [1,2,3] * 5
print(my_list) # [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3]

# finally the 'in' operator also works for lists

my_list = [1,2,3]
print(1 in my_list) # True



# TUPLES
---------
# This is essentially the same as a list, but it can't be changed after creation (immutable)
# this will make more sense when we get to a later part in this tutorial 
# tuples work the same as lists but uses () instead of []

single = (3,)
print(len(single)) # 1
# notice how there is a ',' after the 3
# this lets python know that you're assigning a tuple to single instead of an integer 
# if you put single = (3), python will think it's just an integer 
# and you can't find the len(single) of an integer if it were just (3) instead of (3,)

# and we can do all the same things as we have seen over other sequences: 

my_tuple = ('height', 3, 'age', 70)
print(my_tuple) # ('height', 3, 'age', 70)
print(my_tuple[1]) # 3
print(my_tuple[-1]) # 70
print(my_tuple[:1:-1]) # ('age', 70)

# There is more complete list of all operations and properties of sequences in the link below
# docs.python.org/3/library/stdtypes.html



# Functions
------------
# Think of this as a formula to achieve something
# writing functions help you streamline code so it doesn't need to be copy and pasted here and there

# suppose we have the following formula for the number of standard drinks in a drink

volume = 0.375
percentage = 13.5
drinks = volume * percentage * 0.789
print(drinks)

# But what if we want to perfrom this calculation over different values of volumes and percentages 

def std_drinks(volume,percentage):
	return volume * percentage * 0.789

print(std_drinks(0.375,13.5)) # 3.99431250000004
print(std_drinks(0.586,3.8)) # 1.7569452
print(std_drinks(1.5,0)) # 0.0

# Take a look at another exmaple:
# Calculate the number of standard drinks contained in 'volume'
# of alcoholic drink `percentage` % of alcohol

def std_drinks(volume,percentage):
	return volume * percentage * 0.789

# We use the function to do the calculation
print(std_drinks(0.375,13.5))
# The values taken into the function are called arguments and using by using a func you're calling a func

# Why use functions?
# 1. Saves space by reducing repeated code
# 2. If there was an error in the function we would only have to fix it once rather than every other duplicate 

# We've actually already seen some arguments before, can you guess them? 

len([1,2,3]) # function that calculates the lenght of string/list/tuple
print("hello","bob") # print function that took 2 arguments

# if you notice, functions always have () after the function name lower(), len(), type(), 

# The basic components of a function are:
# 1. The function name - follow the same rule as variables, they must start with a letter or an underscore
def my_function_name

# 2. The arguments - variables that will be passed on into the code segment in the function
def my_function_name(arg1,arg2,arg3):

# 3. The actual computation that the funciton does when called
def my_function_name(arg1,arg2,arg3):
	maxnum = arg1
	if arg1 > maxnum:
		maxnum = num1
	elif arg2 > maxnum:
		maxnum = arg2 

# 4. Some mechanism for returning a value and exiting the function 
def my_function_name(arg1,arg2,arg3):
	maxnum = arg1
	if arg1 > maxnum:
		maxnum = num1
	elif arg2 > maxnum:
		maxnum = arg2 
	return maxnum


# Functions do not display any output on the screen unless the output is explicitly printed 

def silly_fucntion():
	return "I'm silly"

w = silly_fucntion # return value is stored but not displayed
print(w) # returns "I'm silly"


# Note that a function has to be defined before you can call it, so always have your function above you call because python reads top-down

def a_function():
	print("Returning a number: ")
	return 1
	print("Returning a number: ")
	return 3 

# the output will be 
# Returning a number: 
# 1 

# When the return statement is executed, the function "stops" and returns the value given. This means that anything below it will be ignored/not executed 

# A function can have as many arguments as needed 
def a_function(arg1,arg2,...,argn):

# The arguments however need to have different names 
def a_fucntion(a,a,a,): # WRONG
def a_function(a,b,c): # RIGHT

# A function can also have no arguments 
def a_fucntion():
	return -1
print(error_code())


# METHODS 
----------
# These are special functions that belong to specific data types. They are written and called a bit differently.
# An example of a method is upper() method, which converts the string to uppercase and returns it.

my_str = "take the pie out"
print(my_str) # "take the pie out"
prtin(my_str.upper()) # "TAKE THE PIE OUT"

# Just as was the case with functions, methods calls always require parentheses, and if there are not extra (arguments)
# the parentheses should be empty. However methods always get object they're called from as an argument. So in this case
# upper() received my_str as an argument automatically

# Try and write a fucntion that utilises a method to count the number of words in a sentence
# solution below if you can't figure it out, ** tip: use .split()

def word_count(input_str):
	words = input_str.split()
	return len(words)


# One str method that is particulrl useful is format
# The power of format is displayed below 

num1 = 5 
num2 = 6.7

print("The quotient of " + str(num1) + " and " + str(num2)+ " is " + str(num1/num2))
print("The quotient of",num1,"and",num2,"is",num1/num2)

# string concatenation involves casting every value to a string, which is tedious,
# we have no way of controlling the number of decimal places a given float is printed to
# and print with multiple arguments inserts a space between each pair of arguments 

# The power of formal allows us to simplify this

print("The quotion of {} and {} is {:.2f}".format(num1,num2,num1/num2))


# Lets start with a simple example of format:

print("I own {} horses". format(10)) # "I own 10 horses."

# In this example, the format string is "I own {} horses." The format method is used to gnerate a new
# string by substituting a value into a format string. THe empty curly braces {} are used to tell the 
# format method where in the string the value should go.

# For floating point numbers, Python has even finner control. THe format specifier {:6.2f} tells format
# to use at least 6 characters in total and use exactly two digits after the deicmal points

pi = 3.1415926
print("{:<6.2f}".format(pi)) # pad on the right
3.14  # Total of 6 spaces used
print("{:6.2f}".format(pi)) # pad on the left
  3.14# Total of 6 spaces used

# format also has the ability to embed different types (not just numbers) in strings like so:

print("strings: {:s}".format("9743")) # strings: 9743
print("binary number: {:b}".format(9743)) # binary number: 10011000001111
print("integer base 10: {:d}".format(9743)) # integer base 10: 9743 
print("Call me on my {:c}".format(9743)) # (picture of a telephone)
# {:c} converts the integer into a special character 
# It's called Unicode characters 

# If there is nothing before the colon, Python will substitue in the arguments to format in sequence
# i.e. the first argument to format will be substituted for the first occurerence of curly braces, the
# second for the second, etc. You can also, however, index the arguments to format in the same way that
# you index the elemtns of a list, e.g.:

print("{0} {0} It's off to work we go".format("Hi Ho!"))
# Hi Ho! Hi Ho! It's off to work we go

print("""{t1} and {t2} 
	Agreed to have a battle;
For {t1} and {t2}
	Had spoiled his nice new rattle.""".format(t1="Tweedledum",t2="Tweedledee"))

# Tweedledum and Tweedledee
# 	Agreed to have a battle;
# For Tweedledum and Tweedledee
#	Had poiled his nice new rattle. 

# More resources if you want to learn more at:
# pyformat.info 
# docs.python.org/3/library/string.html#format-string-syntax



# ITERATIONS
-------------
# Iterations are used to help repeat something without having to copy and past the code with different
# value each item

print("10 seconds to liftoff!")
print("9 seconds to liftoff!")
print("8 seconds to liftoff!")
print("7 seconds to liftoff!")
print("6 seconds to liftoff!")
print("5 seconds to liftoff!")
print("4 seconds to liftoff!")
print("3 seconds to liftoff!")
print("2 seconds to liftoff!")
print("1 seconds to liftoff!")
print("Lift off!")

# We can easily do this using a loop (for/while)

# WHILE LOOPS

seconds = 10
while seconds > 0:
	print("{} secpmds tp liftoff!".format(seconds))
	sec = sec - 1
print("Lift off!")

# very much like an if statement, the while statement tests whether a condition
# evaluates to true. In the instance it is true, it executes the code associated 
# with the while statement 

# ** you must ensure the while loop terminates (sec = sec -1) if not it'll keep running and never end

# When iterating, it is very common to need to assign values to variables which depend on the previous
# value of the variable. A particularly common one: 

i = 0
print(i) # 0
i = i + 1
print(i) # 1

# or can be written as 

i = 0
print(i) # 0
i += 1
print(i) # 1

# you will see this more often when you start coding 

+= 	# i = i + 1
-= 	# i = i - 1
*= 	# i = i * 1
/= 	# i = i / 1
%= 	# i = i % 1
**=	# i = i ** 1
//=	# i = i // 1


# There is an alternative for exiting a while loop
# a 'break' statement can be used to terminate the loop

word = "rendezvous"
while word:
	if word[0] == 'z':
		word = word[1:]
		break
	word = word[1:]
print(word) # vous

# The code looks at one letter at time, until it finds the 'z' 
# it then removes the z and assigns the remaining letters to word
# in this cause rendezvous -> vous.
# as soon as the it entered the if block and broke out of the loop

# to visualize: use your finger and point it at line 720
# and like python you read each line of code one at a time 
# and just keep repeating until you reach letter z and that's when 
# you can enter the loop and when you hit break, your finger moves to 726



# FOR LOOPS

my_list = [1,2,3]
for elem in my_list:
	print(elem) # 1\n 2\n 3\n

# \n in coding means next line, if you typed this out in your terminal it will be printed as:
# 1
# 2 
# 3

# The variable elem takes each value of my_list one by one until we get to the end of the list

# you can also do the same with strings

my_list = "Hello Bill"
for char in my_list:
	print(char) # H\n e\n l\n l\n o\n \n B\n i\n l\n l\n 

# for loops work better for iteratable items 


# let's look at another example
# Below we are iterating over a text to find the number for vowels (assuming the text is in lower case)

text = "a piece of string"
vowel_count = 0
for letter in text:
	if letter in "aeiou":
		vowel_count += 1
print(vowel_count) # 6

# let's try and combine what we've learnt
# Write a function that takes an input and puts an * after each letter
# Richard --> R*i*c*h*a*r*d*

def make_word(text):
	word = ""
	for letter in text:
		word += letter + "*"
	return(word)

# let's look at another example
# Below we are finding the average of a list of numbers 

numlist= [14,5,7,8,23]
total = 0 
for num in numlist:
	total += num
print(total/len(numlist)) # 11.6

# Lets take a look (while-loop) example:

numlist = [20,1,2,3,4,5,10]
minnum = numlist[0]
i = 1 
while i < len(numlist):
	num = numlist[i]
	if num < minnum[i]:
		minnum = num
	i += 1
print(minnum) # 1

# Thie while loop prints the smallest value in the list, try and visualize what's happening here! 

# let's see how we can do above differently 
# We can utilise the range function 

print(list(range(0,5))) # [0,1,2,3,4,5]
print(list(range(0,2))) # [0,1,2]
print(list(range(1,3))) # [1,2,3]
print(list(range(2,2))) # []

numlist= [14,5,7,8,23]
total = 0 
for num in range(1,len(numlist)):
	num = numlist[i]
	if num < minnum:
		minnum = num
print(minnum)

# another way we can do the above is using indexing

numlist= [14,5,7,8,23]
total = 0 
for num in numlist[1:]:
	if num < minnum:
		minnum = num
print(minnum)


# Let's take a look at another example:

wordlist = ["apples", "bananas", "cantaloupes"]
MIN_WORD_LENGTH = 7
longwords = []
for word in wordlist:
	if len(word) >= MIN_WORD_LENGTH:
		longwords.append(word)
print(longwords) # ["bananas", "cantaloupes"]

# The code above prints words that are longer than 7 or more letters 
# did you notice a new method? .append()
# .append() is a method used to add values to a list 

# now lets try to do the same using a while loop

wordlist = ["apples", "bananas", "cantaloupes"]
MIN_WORD_LENGTH = 7
longwords = []
while wordlist:
	if len(wordlist[0]) >= MIN_WORD_LENGTH:
		longwords.append(wordlist[0])
	wordlist = wordlist[1:]
print(longwords) # ["bananas", "cantaloupes"]

# we can do this without mutating the list, using list indexing

wordlist = ["apples", "bananas", "cantaloupes"]
MIN_WORD_LENGTH = 7
longwords = []
i = 0
while i < len(wordlist):
	if len(wordlist[i]) >= MIN_WORD_LENGTH:
		longwords.append(wordlist[i])
	i += 1
print(longwords) # ["bananas", "cantaloupes"]


# After seeing how you can use a for or while loop to achieve your desired goal
# So how do you know when to use the right one? 
# While loops are slihgtly "fiddlier" than for loops as we need to set up a test in the while condition
# and make sure to update the variable in the test appropriately in the body of our code. 
# in programming, fiddlier means more lines of code and it tends to correlate with a greater margin of error
# and as such for loops should be your default choice. However there are occasions where a while loop leads
# to cleaner code, e.g. in acases here you know that you won't need to iterate over all elements in the iterable
# such as checking for the existence of an element of a particular type in an interable (demonstrated below):

numlist = [3,1,-1,0]
found_negative = False
i = 0
while (not found_negative) and i < len(numlist):
	if numlist[i] < 0:
		found_negative = True
		print("{} contains negative number(s)".format(numlist))
	i += 1
if not found_negative:
	print("{} DOESN'T contain any negative numbers".format(numlist))

# We use found_negative to keep track of whether we have found a negative value or not 
# we can also still do the above with a for loop but arguebly it's cleaner with while 



# MUTABILITY AND ADVANCED SEQUENCES 
------------------------------------
# If you remember we mentioned that tuples were immutable as compared to lists that are mutable
# if a value cannot be changed after it is created, it is immutable. 
# if a value can be change after it is created, it is mutable 
# Lists, dictionaries and sets are mutable
# Everything else is immutable - strings, tuples, numbers(int/float/booleans)

# If an object is mutable, then its value may change, while its id remain constant. 
# Try this code out in your text editor and you will see what this means:

my_list = [1,0]
print("id of my_list:",id(my_list)) # id of my_list: 4140487884
print(my_list) # [1,0]
my_list[0] = 3
print("id of my_list:",id(my_list)) # id of my_list: 4140487884
print(my_list) # [3,0]

# if you try doing this with a tuple you'll get a TypeError because tuples are immutable, try it out! 

# What if you have a list which is mutable in a tuple as seen below:

my_tuple = (7,[])
print("ids of items in tuple:",id(my_tuple[0],id(my_tuple[1]))) # 410594380
my_tuple[1].append("hello")
print(my_tuple) # (7,["hello"])
print("ids of items in tuple:",id(my_tuple[0],id(my_tuple[1]))) # 410594380

# It is important to understand that the assignment operator (=) points a variable to a particular object: 

# The object id of 5 
print(id(5))
q = 5 
# The object now pointed tob y the variable q.
print(id(q))


# When we point a variable to a mutable objet, if we change the value of the object using one variable, 
# we will see the cahnge in the other variable, as they both point to the same object! 

list1 = [1,2,3]
print("The id of the object pointed to by list1:", id(list1)) # The id of the object pointed to by list1: 414044282
list2 = list1
print("The id of the object pointed to by list2:", id(list2)) # The id of the object pointed to by list2: 414044282
list1.append(8)
print(list1) # [1,2,3,8]
print(list2) # [1,2,3,8]

# Notice how we never did anything to list2 vairable. This would never happen with an immutable object,
# be cause we cannot change its value. Note also that we can see when two variables point to the same 
# object with the is operator

list1 = [5]
list2 = list1
print(list1 is list2) # True

# One place where you should be particularly aware of mutability is when you call a function with a vairable which
# has been assigned to a mutable object, and the function mutates the argument. The function below exploits this to
# swap the first and last elements of a list wihtout ever returning anything.

def swap(a_list):
	tmp = a_list[0]
	a_list[0] = a_list[-1]
	a_list[-1] = tmp
my_list = [1,2,3]
swap(my_list)
print(my_lsit) # [3,2,1]



# Useful List Methods (Part1)
# Python allows you mutate a list using some built in methods

# .append() - adds a new item to the end of the list

chomsky = ['colour','odour','taste']
chomsky.append('feeling')
print(chomsky) # ['colour','odour','taste','feeling']

# .pop() - removes the final element or if called with a numeric arg, removes the element of that index

chomsky = ['colour','odour','taste']
print(chomsky.pop()) # 'taste'
print(chomsky) # ['colour','odour']
print(chomsky.pop(0)) # 'colour'
print(chomsky) # ['odour']

# .insert() - inserts an item into a list at a specific index (remember that index starts at 0)

chomsky = ['colour','odour','taste']
chomsky.insert(1,'sleep')
print(chomsky) # ['colour,'sleep','odour','taste']

# .remove() - deletes the first occurrence of an item in a list. An error occurs if the item is not in the list
# an error occurs if the argument to remove is not in the list

chomsky = ['colour','odour','taste']
chomsky.remove('colour')
print(chomsky) # ['odour','taste']

# .index() - non-mutating method that returns the position of the first occurrence of an item
# an error occurs if the argument to index is not in the list 

chomsky = ['colour','odour','taste']
print(chomsky.index('taste')) # 2  


# Because lists are mutable, you should be careful when iterating over them. If you change the list 
# while you iterate over it, this could have some unexpected effets. 
# For example, the following code was suppose to print each element of a list, then remove it

my_list = [1,2,3,4]
for i in my_list:
	print(i) 
	my_list.remove(i)
print(my_list) # [2,4]


# As we saw earlier, Python provides a conveninet way to turn a string into a list of words, using .split()
sniglet = "The one cube left"
sniglet_words = sniglet.split()
print(sniglet_words) # ["The", "one", "cube", "left"]

# By default, split segments based on "whitespace", however it's you can change this behaviour by speciying a separator

print("1,2,3".split(','))) # 123
print("look b4 you leap".split('b4')) # ['look ',' you leap']


# Let's try a little exercise
# Write a function that uses a for loop and break that takes a single argument text in the form of a string, and returns 
# a list of the all-alphabetic words in text up until the first word containing a non-alphabetic character. 
# TIP: use .isalpha() that returns true or false if the text is made up of all alphabetical cahracters, otherwise false

wordlist("How much wood could a k9 chuck")
# ['How', 'much', wood', 'could', 'a']
wordlist("99 Luftballons")
# []
wordlist("It can kill 69 birds")
# ['It', 'can', 'kill']

# Solution below:

def wordlist(text):
	sentence = text.split()
	result = []
	for i in sentence:
		if i.isalpha():
			result.append(i)
		else:
			break
	return result


# Sorting 
# One list operation that you will find many applications for is sorting the elements
# There are two ways of doing this, which will you will inevitably confuse at some point 
# because of the names being so similar
# 1. sorted() function
# 2. sort() method

# sorted() - takes a list and returns a new list with the elements in sorted order (without mutating the original list)
randlist = [4,1,3.0,2,5]
print(sorted(randlist)) # [1,2,3.0,4,5]
print(randlist) # [4,1,3.0,2,5]

# it can also be applied to a list of strings, in which case the sort order is based on the underlying Unicode values:

print(sorted(['abacus', 'a', 'aardvark', 'ABC'])) # ['ABC', 'a', 'aardvark', 'abacus']

# if you try to used sorted with mixed value types you will get a TypeError

print(sorted('1',2,3,'4.0','five')) # TypeError

# if you want to reverse-sort, simply set the optional reverse keyword to true:

print(sorted(1,4,3.0,2,5), reverse = True) # [5,4,3.0,2,1]



# sort() - operates in-place, in that it mutates the list so that the elements are sorted

randlist = [4,1,3.0,2,5]
print(A.sort()) # None
print(randlist) # [1,2,3.0,4,5]

# whereas the following is almost certainly not the desired effect:

randlist = [4,1,3.0,2,5]
randlist = randlist.sort()
print(randlist) # None

# one way to avoid the confusion is to use sorted exclusively, and remember to reassign the result back to thel ist ariable (as above) 
# if the intentionis to sort a list in-place. Another advantage of sorted is that i can be applied to any sequence, including lists and
# tuples (althought it will always return a list):

print(sorted('bananas')) # ['a','a','a','b','n','n','s']
print(sorted((3,1,5))) # [1,3,5]


# Let's use what we've learnt
# Write a funciton sorted_words(wordlist) that takes a single list-of-words argument wordlist,
# and returns a sorted list of words in wordlist where the letters are alphabetically sorted
# e.g. abc or bet are sorted, cat and elephant are not 
# TIP: use list() that takes an object and puts it into a list separating each character with a ','

def sorted_words(wordlist):
	answer = []
	for word in wordlist:
		if sorted(word) == list(word):
			answer.append(word)
	return answer 




# DICTIONARIES 
---------------
# You will now be introduced to a thing called mapping. 
# Mapping is when you have a key and a value. The key points to a value 
# An example of this is the Dewey Decimal System, where a specific code leads you to a book

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney',
			'Queensland' : 'Brisbane',
			'Tasmania' : 'Hobart'}

print(capitals['Tasmania']) # Hobart

# This dictionary maps states to their corresponding capital cities 

# The keys in the above dictionary are strings which represent the names of the Australian states.
# Each key maps to a value, which also happens to be a string in this case. In the general case,
# the keys and values can be of different types. 

# Dictionary values are constructed using the curly brace characters {}. As a special case, you
# can construct an empty dictionary using an opening and closing brace with nothing in between

example_empty_dict = {}

# As you shall soon see, it is possible to add new mappings to an existing dictionary, so it 
# can be useful to construct empty dictionaries and later add values as necessary. 

# Like lists and strings, dictionaries are indexable. However, the indices of dictionaries are keys
# of arbitrary value, whereas the indices of lists and strings are always integers. A given key can 
# only occur once in the dictionary, and is associated with a unique value (but you can, of course
# make the value a list containing multiple objects). You can look up values in a dictionary using 
# the normal indexing notation:

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney',
			'Queensland' : 'Brisbane',
			'Tasmania' : 'Hobart'}

print(capitals['Victoria']) # Melbourne
print(capitals['New South Wales']) # Sydney
print(capitals['ACT']) # This is an ERROR because the index does not exist in the dictionary

# Other ways of indexing dictionaries are hte pop and get methods. These return a value 
# given a key. As you might expect, pop deltes the (key, value) pair after returning 
# the value, just like with lists. 

my_dict = {"Age":34,"Anna":"Joe","Jobs":"Steve"}
print(my_dict.get("Age")) # 34
print(my_dict) # {"Age":34,"Anna":"Joe","Jobs":"Steve"}
print(my_dict.pop("Jobs")) # Steve
print(my_dict) # {"Age":34,"Anna":"Joe"}

# The clear method deletes the entire contents of the dictionary, and del removes
# a key:value pair without returning anything 

my_dict = {"Age":34,"Anna":"Joe","Jobs":"Steve"}
del my_dict["Age"]
print(my_dict) # {"Anna":"Joe","Jobs":"Steve"}
my_dict.clear() 
print(my_dict) # {}


# You can change the value which is associated with a key or add a new key and value pair
# to the dictionary using the assignment (=) operator

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney',
			'Queensland' : 'Brisbane',
			'Tasmania' : 'Hobart'}

print(capitals['Victoria']) # Melbourne

capitals['Victoria'] = "Melbum"
capitals['ACT'] = "Canberra"

print(capitals['Victoria']) # Melbum
print(capitals['ACT']) # Canberra  

# Victoria is now mapped to Melbum instead of Melbourne and before ACT was not present
# in the dictionary before assignment statement, so the above code extends the dictionary
# with a new mapping


# You can test if a key is present in a dictionary using the in operator.
# Try running the following code a few times, entering both valid and invalid state names:

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney',
			'Queensland' : 'Brisbane',
			'Tasmania' : 'Hobart'}

state = input("Enter a state name: ")
if state in capitals:
	print(capitals[state])
else:
	print(state, 'not found')


# You can get the keys in a dictionary using the keys method. 
# keys returns a spcial iterable collection called dict_keys
# that supports iteration and the in operator like a list, 
# but does not support indexing 

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney'}

keys = capitals.keys()

print("The keys:",keys) # (['Victoria', 'New South Wales'])

print("Looping through all keys:")
for key in keys:
	print(key) # Victoria\n New South Wales

print("is 'Victoria' in keys?",'Victoria' in keys) # Is 'Victoria' in keys? True
print(keys[0]) # THIS IS AN ERROR


# You can get the values (separate from the keys) using the 
# values method. values returns a special iterable collection
# called a dict_values object that acts much like dict_keys object:

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney'}

d_values = capitals.values()

print("The values",d_values) # (['Melbourne','Sydney'])

print("Looping through all values:")
for value in d_values: 
	print(value) # Melbourne\n Sydney

print("Is 'Victoria' in values?",'Victoria' in d_values) # "Is 'Victoria' in values? False"
print(d_values[0]) # THIS IS AN ERROR


# Another useful method for dictionaries is the items method. Like keys
# and values, items returns a view object called dict_items containing 
# tuples of the (key,value) pairs

# You can also convert these view objects into lists using list. 

capitals = {'Victoria' : 'Melbourne',
			'New South Wales' : 'Sydney'}

d_items = capitals.items()

print("Items in this dictionary:",d_items) 
# Items in this dictionary: dict_items([('Victoria','Melbourne'),('New South Wales','Sydney')])
print("As a list:",list(d_items)) 
# As a list: [('Victoria','Melbourne'),('New South Wales','Sydney')]

for (key,value) in d_items:
	print(key,value) # Victoria Melbourne
					 # New South Wales Sydeny


# Keys for dictionaries can only be immutable objects. That means you can use: 
# int, float, str, tuple, bool as keys
# But you cannot use: list, set.
# Could you use ditionaris? Are they mutable or immutable?

# Another important characterisc of dictionaries is that they are not ordered.
# This can be seen by observing the oder of (key,value) pairs when items method
# is called is different to the order of insertion of the pairs. This also means
# that when you iterate over a dictionary, you have to keep this in mind: 
# the order may change! 

d = {1:0, 2:0, -1:4, "hello":0, 9:9, 2:2, 2:3}
print(list(d.items())) # [(1,0),(2,3),(-1,4),('hello',0),(9,9)]

# What happened when we put the same key in with a different value?
# The final value is kept (remember keys need to be unique)


# A common programming task is to tally how many times various items appear in a piece 
# of data. Below is an example program which counts the number of occurences of each
# letter in the first paragraph of Moby Dick:

MOBY = "Call me Ishmael. Some years ago - never mind how long precisely - having little or no money"

tally = {}
for char in MOBY:
	if char in tally:
		tally[char] += 1
	else:
		tally[char] = 1

print(tally['C']) # 1
print(tally['I']) # 1


# After counting all the character in mOby Dick's first paragraph, you can do inderesting things
# with the information. For instance, you can print out a simple bar chart of the frequencies for
# all the upper case characters which appear in the text: 

tally = {}
for char in MOBY:
	if char in tally:
		tally[char] += 1
	else:
		tally[char] = 1

for key in tally.keys():
	if key.isupper():
		print(key + ': ' + '=' * tally[key])

# N: =
# I: =======
# C: =
# T: ==
# W: ==
# S: ==

# Something like that, that's not the actual answer























